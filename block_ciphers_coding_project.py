# -*- coding: utf-8 -*-
"""block ciphers coding project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rIJA0HPhl80Fn8N3ZLEN20KWMeTiEa4X
"""

import random

# Function to add padding to a message
def pad(message, block_size):

    padding_size = block_size - (len(message) % block_size)
    padding = bytes([padding_size] * padding_size)

    return message + padding

# Function to remove padding from a message
def unpad(padded_message):

    padding_size = padded_message[-1]

    return padded_message[:-padding_size]

# Function to perform XOR operation between two byte blocks
def xor_bytes(b1, b2):
    # Function xor_bytes output
    result = bytes(x ^ y for x, y in zip(b1, b2))

    return result

# Function to perform a simple permutation
def permute(block):


    half_len = len(block) // 2
    result = block[half_len:] + block[:half_len]

    return result

# Function to encrypt a data block with XOR and permutation
def encrypt_block(block, key):
    # XOR encryption operation
    encrypted_block = xor_bytes(block, key)

    # Permutation after XOR operation
    encrypted_block = permute(encrypted_block)

    return encrypted_block

# Main function to encrypt an entire message
def encrypt(message, key):


    block_size = len(key)

    # Add padding to the message
    padded_message = pad(message, block_size)

    ciphertext = b''

    # Block-wise encryption
    for i in range(0, len(padded_message), block_size):
        block = padded_message[i:i+block_size]

        # Encryption operation
        encrypted_block = encrypt_block(block, key)
        ciphertext += encrypted_block

    return ciphertext

# Function to decrypt a data block with XOR and inverse permutation
def decrypt_block(block, key):

    # Inverse permutation before XOR operation
    block = permute(block)

    # XOR decryption operation
    decrypted_block = xor_bytes(block, key)

    return decrypted_block

# Main function to decrypt an entire message
def decrypt(ciphertext, key):

    block_size = len(key)

    padded_message = b''

    # Block-wise decryption
    for i in range(0, len(ciphertext), block_size):
        block = ciphertext[i:i+block_size]

        # Decryption operation
        decrypted_block = decrypt_block(block, key)
        padded_message += decrypted_block

    # Remove padding
    message = unpad(padded_message)
    return message

#Tests functions

# Function to add padding to a message
def test_pad():
    message = b"Hello"
    block_size = 8
    padded_message = pad(message, block_size)
    assert len(padded_message) % block_size == 0, "Padding test failed"

# Function to remove padding from a message
def test_unpad():
    padded_message = b"Hello\x03\x03\x03"
    message = unpad(padded_message)
    assert len(message) == len(padded_message) - padded_message[-1], "Unpadding test failed"

# Function to perform XOR operation between two byte blocks
def test_xor_bytes():
    b1 = b"\x01\x02\x03"
    b2 = b"\x04\x05\x06"
    result = xor_bytes(b1, b2)
    assert result == bytes([x ^ y for x, y in zip(b1, b2)]), "XOR bytes test failed"

# Function to perform a simple permutation
def test_permute():
    block = b"12345678"
    result = permute(block)
    assert result == b"56781234", "Permutation test failed"

# Function to encrypt a data block with XOR and permutation
def test_encrypt_block():
    block = b"Hello123"
    key = b"ABCDEFGH"
    encrypted_block = encrypt_block(block, key)
    assert encrypted_block != block, "Encrypt block test failed"

# Main function to encrypt an entire message
def test_encrypt():
    message = b"Hello World!"
    key = b"ABCDEFGH"
    ciphertext = encrypt(message, key)
    assert ciphertext != message, "Encrypt test failed"

# Function to decrypt a data block with XOR and inverse permutation
def test_decrypt_block():
    block = b"encrypted"
    key = b"ABCDEFGH"
    decrypted_block = decrypt_block(block, key)
    assert decrypted_block != block, "Decrypt block test failed"

# Main function to decrypt an entire message
def test_decrypt():
    ciphertext = b"\x07\xa3\xd7*\x82\x19g\xe6\xa3u\x92\xb3"
    key = b"ABCDEFGH"
    decrypted_message = decrypt(ciphertext, key)
    assert decrypted_message != ciphertext, "Decrypt test failed"

# Run the test functions
test_pad()
test_unpad()
test_xor_bytes()
test_permute()
test_encrypt_block()
test_encrypt()
test_decrypt_block()
test_decrypt()


print("All tests passed!")

# user interface

import random
def generate_aes_key(key_size):
    # Generate a random key in bytes
    key = bytes([random.randint(0, 255) for _ in range(key_size)])
    return key

# Specify the key size (in bits)
key_size = 8
key = generate_aes_key(key_size)

print(f"Generated Key: {key}")
message = b'Test for the presentation'  # Byte string (bytes)

encrypted_message = encrypt(message, key)
print(f'Encrypted message: {encrypted_message}')

decrypted_message = decrypt(encrypted_message, key)
print(f'Decrypted message: {decrypted_message.decode("utf-8")}')